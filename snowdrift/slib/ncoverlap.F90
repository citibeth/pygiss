! Module to read the overlap.nc files generated by the C++ code
!
! bash-3.2$ ncdump -h overlap.nc
! netcdf overlap {
! dimensions:
! 	one = 1 ;
! 	grid1.overlap_grid_cells = 120 ;
! 	grid2.overlap_grid_cells = 2500 ;
! 	overlap.num_overlaps = 3861 ;
! 	overlap.num_grids = 2 ;
! 	grid2.x_boundaries.length = 51 ;
! 	grid2.y_boundaries.length = 51 ;
! variables:
! 	int grid1.info(one) ;
! 		grid1.info:name = "gcm" ;
! 	int grid1.grid_index(grid1.overlap_grid_cells) ;
! 	double grid1.native_area(grid1.overlap_grid_cells) ;
! 	double grid1.proj_area(grid1.overlap_grid_cells) ;
! 	int grid2.info(one) ;
! 		grid2.info:name = "ice" ;
! 		grid2.info:type = "XY" ;
! 	int grid2.grid_index(grid2.overlap_grid_cells) ;
! 	double grid2.native_area(grid2.overlap_grid_cells) ;
! 	double grid2.proj_area(grid2.overlap_grid_cells) ;
! 	int overlap.grid_index(overlap.num_overlaps, overlap.num_grids) ;
! 	double overlap.area(overlap.num_overlaps) ;
! 	double grid2.x_boundaries(grid2.x_boundaries.length) ;
! 	double grid2.y_boundaries(grid2.y_boundaries.length) ;
! }

module ncoverlap_mod

use ncutil_mod
use netcdf

implicit none

integer, parameter :: GT_UNKNOWN=0, GT_LATLON=1, GT_XY=2

! ---------- Stuff read from netCDF overlap file

! Specialization for xy data type
type :: ncgrid_xy_t
	real*8, dimension(:), allocatable :: x_boundaries
	real*8, dimension(:), allocatable :: y_boundaries
end type ncgrid_xy_t

! Information related to one grid
type :: ncgrid_t
	integer, dimension(:), allocatable :: grid_index
	real*8, dimension(:), allocatable :: native_area
	real*8, dimension(:), allocatable :: proj_area
	integer :: type		! GT_*

	! Optional stuff (polymorphism of sorts)
	type(ncgrid_xy_t) :: xy
end type ncgrid_t

! The overall overlap file
type ncoverlap_t
	type(ncgrid_t) :: grid1, grid2
	integer, dimension(:,:), allocatable :: grid_index
	real*8, dimension(:), allocatable :: area
end type ncoverlap_t

! ========================================================
contains

! Reads info about one grid
! @param nc netCDF file handle
! @param name0 Name of the grid to read
! @param name_len Length of name0 string
! @param ncgrid Place for output
subroutine ncgrid_read(nc, name0, name_len, ncgrid)
	integer, intent(in) :: nc
	character(*), intent(in) :: name0
	integer, intent(in) :: name_len
	type(ncgrid_t), intent(inout) :: ncgrid

	character(100) :: name
	character(50) :: stype

	name(:) = name0(1:name_len)

	name(name_len+1:) = '.grid_index '
	call nc_read_1d_array_int(nc, name, ncgrid%grid_index)
	name(name_len+1:) = '.native_area '
	call nc_read_1d_array_double(nc, name, ncgrid%native_area)
	name(name_len+1:) = '.proj_area '
	call nc_read_1d_array_double(nc, name, ncgrid%proj_area)

	name(name_len+1:) = '.info '
	call nc_read_attribute(nc, name, 'type', stype)

	ncgrid%type = GT_UNKNOWN
	select case (trim(stype))
		case('xy')
			ncgrid%type = GT_XY
			! allocate(ncgrid%xy)		! gfortran buggy with allocatable scalars
			name(name_len+1:) = '.x_boundaries '
			call nc_read_1d_array_double(nc, trim(name), ncgrid%xy%x_boundaries)
			name(name_len+1:) = '.y_boundaries '
			call nc_read_1d_array_double(nc, trim(name), ncgrid%xy%y_boundaries)
	end select

end subroutine ncgrid_read

! Reads entire overlap.nc file
! @param nc netCDF file handle
subroutine ncoverlap_read(fname, fname_len, ncoverlap)
	character(fname_len), intent(in) :: fname
	integer, intent(in) :: fname_len
	type(ncoverlap_t), intent(inout) :: ncoverlap

	integer :: nc

	call check(nf90_open(trim(fname), NF90_NOWRITE, nc))

	! ----- Read about the two grids individually
	call ncgrid_read(nc, 'grid1', 5, ncoverlap%grid1)
	call ncgrid_read(nc, 'grid2', 5, ncoverlap%grid2)

	! ----- Read about how they overlap
	call nc_read_2d_array_int(nc, 'overlap.grid_index', ncoverlap%grid_index)
	call nc_read_1d_array_double(nc, 'overlap.area', ncoverlap%area)

	call check(nf90_close(nc))
end subroutine ncoverlap_read

end module ncoverlap_mod

#if 0
program test

use ncoverlap_mod

	type(ncoverlap_t) :: nco
	call ncoverlap_read('overlap.nc', 10, nco)
!	call ncoverlap_read('overlap.nc')

	print *,nco%grid1%grid_index(1:5)
	print *,nco%grid1%native_area(1:5)
	print *,nco%grid1%proj_area(1:5)
	print *,nco%grid1%proj_area(1:5) / nco%grid1%native_area(1:5)
	print *

	print *,nco%grid2%grid_index(1:5)
	print *,nco%grid2%native_area(1:5)
	print *,nco%grid2%proj_area(1:5)
	print *,nco%grid2%proj_area(1:5) / nco%grid2%native_area(1:5)
	print *

	print *, nco%grid_index(:,1:5)
	print *, nco%area(1:5)



end program test
#endif
